# Тестовое задание для стажёра Backend (осенняя волна 2025)

### Выполнила: Виноградова Ангелина

## Запуск решения

Запуск решения осуществляется несколькими способами:

```docker-compose up```

```make up```

или

```make build``` -- для запуска с соответствующим флагом

`.env` находиться в корне проекта

## Вопросы и решения

1. Выбор фреймворка

   > В первую очередь при разработке решения стоит выбор фреймворка. Я выбрала Gin за его удобство, производительность и
   популярность.

2. Неполнота апи

   > При написании сервиса меня смутило отсутствие сообщения об ошибке при отсутствии юзера по данному UserID при
   запросе
   вывода всех PullRequest данного юзера (ручка `/users/getReview`).
   Мною было принято решение дополнить апи и реализовать данный функционал.

3. Допущение в переназначении

   > В дополнения к условиям выбора юзера для PullRequest я добавила условие на приоритизацию выбора тех, у кого меньше
   PullRequest`ов в ожидании на просмотр

4. Вопрос миграций

   > Для удобства разработки я выбрала библиотеку `goose` для миграций PostgreSQL.

   > Так же исходя из удобства запуска решения, поднятие миграций происходит во время каждого поднятия сервиса,
   это позволяет быть уверенным, что если сервис был поднят, то все необходимые миграции уже настроены.

   > Миграции моего проекта можно увидеть в `./migrations`.

5. Вопрос генерации API

   > Для генерации я использовала библиотеку `oapi-codegen`, которую вызывала командой
   `go generate ./...` или аналогичной `make gen`. Вызываемые команды oapi-codegen можно посмотреть в `./oapi-gen`.
   Это позволило мне ускорить разработку из-за готовых генераций структур.

   > Для внутренней работы приложения я использовала DTO, что позволяет иметь гибкость в бизнес
   логике
   и разделяет ответственность.

6. Вопрос обработки ошибок

   > При разработке стоял вопрос как обрабатывать ошибки так, чтобы внутренние ошибки сервиса не открывали данные
   проекта
   на внешний сервис. Я решила, что ошибки сервиса не включенные в ожидаемые ошибки бизнес логики, будут возвращать 500,
   с подписью, что это внутренняя ошибка сервиса.

   > Ошибки же бизнес логики обрабатываются, с использованием кастомных ошибок, находящихся в пакете `cerr`.
   В идеале такие ошибки должны отлавливаться на сервисном слое, где уже и будет происходить определение типа ошибки,
   но у меня не получилось это сделать не нарушив целостность репозиторного слоя, поэтому определение большинства бизнес
   ошибок
   происходит на репозиторном слое, все ошибки не пойманные отдельно обрабатываются функцией в `cerr`, приводя все
   ошибки в единый вид.
   После, на уровне ручек происходит обертка ошибок в вид апи, так же функцией в `cerr`.

7. Дополнительное задание: Статистика
   > Мною был выбран вариант статистики по каждому юзеру (количество PullRequest в которых он reviewer, среднее время от
   Created
   до Merged PullRequest) и статистики по команде (среднее время по всем PullRequest команды, и список статистики
   каждого члена команды)

8. Дополнительное задание: Тестирование
   > Я реализовала e2e тестирование всех предложенных ручек. Вызов совершается по команде `make test`, код тестирования
   можно найти в `./e2e_test/tests`

   > Замечу, что при тестировании очищается база данных, для того чтобы при повторном тестировании не было необходимости
   очищать ее.
9. Дополнительное задание: Линтер
   > Я использовала golangci-lint, его настройки лежат в `./.golangci.yml`, вызывается `make lint`
